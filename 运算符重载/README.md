# C++ operator运算符重载：成员函数 vs 全局函数

**核心定位**：C++ 中成员函数重载运算符和全局函数重载运算符的核心区别，这是掌握运算符重载的关键 —— 两者在参数规则、适用场景、访问权限等方面差异显著，选对重载方式才能让代码既规范又易维护。

## 一、核心区别总览（表格对比，一目了然）

| 对比维度 | 成员函数重载运算符 | 全局函数重载运算符 |
|---------|------------------|------------------|
| **this 指针** | 有（隐式指向左操作数） | 无（所有操作数需显式传入） |
| **参数数量** | 单目运算符：0 个（仅操作 this）<br>双目运算符：1 个（仅传右操作数） | 单目运算符：1 个（操作数）<br>双目运算符：2 个（左操作数 + 右操作数） |
| **访问权限** | 可直接访问类的所有成员（public/protected/private） | 仅能访问 public 成员；访问 private/protected 需声明为类的 friend（友元） |
| **操作数限制** | 左操作数必须是当前类的对象（因为 this 指向左操作数） | 左 / 右操作数类型灵活（可是基础类型、其他类对象） |
| **强制规则** | 赋值类运算符（=、+=、-= 等）必须用成员函数重载 | 流运算符（<<、>>）必须用全局函数重载 |
| **调用方式** | `obj.operator@()`（如 `p1.operator+(p2)`） | `operator@(obj1, obj2)`（`operator+(p1, p2)`） |
