| 构造函数类型 | 核心定义 / 语法特征 | 核心行为 | 适用场景 | 关键注意事项 / 风险 | 性能特点 |
|------------|-------------------|---------|---------|-------------------|---------|
| 1. 默认构造函数 | 无参构造，ClassName()；编译器自动生成（无自定义构造时） | 初始化 "空对象"，成员变量赋默认值（如 int=0、指针 = nullptr） | 创建无初始值的对象、数组初始化（ClassName arr[5]） | 自定义任何构造后，编译器不再自动生成，需手动定义 | 无开销，极快 |
| 2. 浅拷贝构造（默认） | ClassName(const ClassName& other)；编译器自动生成 | 逐字节复制成员变量，指针仅复制地址（共享动态资源） | 无动态资源的简单类（如仅包含 int、double 等基本类型） | 含动态资源时，易引发重复释放内存、野指针、数据篡改 | 快，但有内存安全风险 |
| 3. 深拷贝构造 | 手动实现 ClassName(const ClassName& other)，重新分配动态内存并复制内容 | 为新对象分配独立内存，复制原对象资源内容（资源不共享） | 类包含动态资源（指针、动态数组、文件句柄等） | 必须手动释放旧资源（若有），避免内存泄漏 | 有内存分配 / 拷贝开销，中等 |
| 4. 移动构造函数 | ClassName(ClassName&& other) noexcept（C++11+），参数为右值引用 | 接管临时对象（右值）的资源，原对象置空（不复制资源） | 临时对象赋值、函数返回对象、频繁创建 / 销毁对象的场景 | 必须将原对象资源置空，避免析构时重复释放；std::move 可手动触发 | 零拷贝，性能极高 |
| 5. 带参数（重载）构造 | ClassName(参数1, 参数2...)，支持多参数、多版本重载 | 按传入参数初始化对象成员，灵活定制对象初始状态 | 需要自定义初始值的场景（如 Person("张三", 20)） | 重载需满足参数列表不同（个数 / 类型 / 顺序）；初始化列表比函数体内赋值更高效 | 无额外开销，灵活 |
| 6. 委托构造函数 | ClassName(参数) : ClassName(其他参数)（C++11+），初始化列表调用同类其他构造 | 复用已有构造逻辑，减少代码冗余 | 类有多个构造函数，逻辑重叠时（如默认分数的 Student 构造） | 禁止循环委托（A→B→A）；委托后函数体在被委托构造执行后运行 | 与被委托构造性能一致 |
| 7. 转换构造函数 | 单参数构造 ClassName(类型 参数)，可加 explicit（C++11+） | 实现 "参数类型→类对象" 的转换（隐式 / 显式） | 需要类型自动转换的场景（如 Integer i = 100） | 无 explicit 易引发意外隐式转换；加 explicit 仅允许显式转换 | 与普通构造性能一致 |
| 8. 拷贝赋值运算符重载 | ClassName& operator=(const ClassName& other)，处理已存在对象的赋值 | 释放当前对象旧资源，深拷贝原对象资源（区别于拷贝构造的 "创建新对象"） | 已创建对象的赋值操作（如 s2 = s1） | 必须处理自赋值（this == &other）；需和深拷贝构造配套实现 | 与深拷贝构造性能一致 |
| 9. 移动赋值运算符重载 | ClassName& operator=(ClassName&& other) noexcept（C++11+） | 接管右值对象的资源，赋值给已存在对象 | 已创建对象接收临时对象赋值（如 s3 = std::move(s1)） | 需和移动构造配套实现；原对象需置空 | 零拷贝，性能极高 |
| 10. 聚合构造（聚合初始化） | 无自定义构造的聚合类，ClassName{参数1, 参数2...}（C++11+） | 按成员顺序直接初始化聚合类成员，无需定义构造函数 | 简单结构体 / 类（无自定义构造、无私有成员、无虚函数） | 聚合类需满足 "无自定义构造、无虚函数、无私有 / 保护成员" 等条件 | 无开销，极简 |
